<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>KostenÃ¼bersicht</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      background-color: #9a8c98;
      height: 100vh;
      overflow: hidden;
      user-select: none;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .circle {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      background: silver;
      position: fixed;
      cursor: grab;
      z-index: 1;
      user-select: none;
      touch-action: none;
      box-shadow: 0 0 15px rgba(52,144,220,0.3);
      transition: background-color 0.3s ease;
    }
    .circle.active {
      background-color: white;
      cursor: grabbing;
    }
    .content-wrapper {
      position: relative;
      z-index: 10;
      width: 100%;
      max-width: 400px;
      background: white;
      border-radius: 1rem;
      padding: 1.5rem;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>

  <div class="circle" style="top: 50px; left: 50px;"></div>
  <div class="circle" style="top: 50px; right: 50px;"></div>
  <div class="circle" style="bottom: 50px; left: 50px;"></div>
  <div class="circle" style="bottom: 50px; right: 50px;"></div>

  <div class="content-wrapper">
    <h1 class="text-2xl font-bold text-center mb-4">ðŸ“Š KostenÃ¼bersicht</h1>
    <div id="ausgabe" class="space-y-4"></div>
    
    <div class="flex gap-2 mt-6">
      <button onclick="localStorage.removeItem('kosten'); location.reload();" class="flex-1 bg-red-500 hover:bg-red-600 text-white py-2 rounded">ðŸ—‘ Alle lÃ¶schen</button>
      <button onclick="window.location.href='input.html'" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 rounded">âž• Neue Eingabe</button>
    </div>
  </div>

  <script>
  // Daten anzeigen
  let daten = JSON.parse(localStorage.getItem("kosten")) || [];
  let ausgabeDiv = document.getElementById("ausgabe");

  if (daten.length === 0) {
    ausgabeDiv.innerHTML = "<p class='text-center text-gray-500'>Keine EintrÃ¤ge vorhanden.</p>";
  } else {
    let gesamt = daten.reduce((sum, e) => sum + e.wert, 0);
    let teilnehmer = [...new Set(daten.map(e => e.name))];
    let proPerson = gesamt / teilnehmer.length;

    // Summe je Teilnehmer
    let zahlungen = {};
    teilnehmer.forEach(t => zahlungen[t] = 0);
    daten.forEach(e => {
      zahlungen[e.name] += e.wert;
    });

    // Verrechnung: Restbetrag pro Teilnehmer (proPerson - gezahlt)
    // positiv = muss noch zahlen, negativ = bekommt zurÃ¼ck
    let restBetrag = {};
    teilnehmer.forEach(t => {
      restBetrag[t] = proPerson - zahlungen[t];
    });

    let html = `
      <div class="text-center">
        <h2 class="text-xl font-semibold">Gesamtkosten: <span class="text-green-600">${gesamt.toFixed(2)} â‚¬</span></h2>
        <h3 class="text-lg">Pro Person: <span class="text-blue-600">${proPerson.toFixed(2)} â‚¬</span></h3>
        <p class="text-gray-600">Teilnehmer: ${teilnehmer.join(", ")}</p>
      </div>
      <ul class="divide-y divide-gray-200">
    `;
    daten.forEach(e => {
      html += `<li class="py-2 flex justify-between">
                <span><strong>${e.name}</strong> (${e.grund})</span>
                <span class="text-gray-800">${e.wert.toFixed(2)} â‚¬</span>
              </li>`;
    });
    html += "</ul>";

    // Kleine Auflistung, wer noch zahlen muss oder zurÃ¼ckbekommt
    html += `<div class="mt-6 text-center">
               <h3 class="text-lg font-semibold mb-2">Verrechnung</h3>
               <ul class="divide-y divide-gray-300 max-w-sm mx-auto">
    `;
    teilnehmer.forEach(t => {
      let wert = restBetrag[t];
      let text, cssClass;
      if (wert > 0.01) {
        text = `muss noch <strong>${wert.toFixed(2)} â‚¬</strong> zahlen`;
        cssClass = "text-red-600";
      } else if (wert < -0.01) {
        text = `bekommt <strong>${(-wert).toFixed(2)} â‚¬</strong> zurÃ¼ck`;
        cssClass = "text-green-600";
      } else {
        text = `ist ausgeglichen`;
        cssClass = "text-gray-700";
      }
      html += `<li class="py-1 ${cssClass}"><strong>${t}</strong> ${text}</li>`;
    });
    html += "</ul></div>";

    ausgabeDiv.innerHTML = html;
  }

    // drag bouncing for circles
    const circles = document.querySelectorAll('.circle');

    circles.forEach((circle, index) => {
      let isDragging = false;
      let startX, startY;
      let origX, origY;
      let lastX, lastY;
      let velocityX = 0;
      let velocityY = 0;
      let animationFrame;

      // initial pos
      function getInitialPos(elem) {
        const rect = elem.getBoundingClientRect();
        return {x: rect.left, y: rect.top};
      }

      const basePos = getInitialPos(circle);

      circle.style.left = basePos.x + 'px';
      circle.style.top = basePos.y + 'px';

      circle.addEventListener('mousedown', dragStart);
      circle.addEventListener('touchstart', dragStart, {passive: false});

      function dragStart(e) {
        e.preventDefault();
        isDragging = true;
        circle.classList.add('active');
        
        const rect = circle.getBoundingClientRect();
        origX = rect.left;
        origY = rect.top;

        if(e.type === 'mousedown') {
          startX = e.clientX;
          startY = e.clientY;
          window.addEventListener('mousemove', dragging);
          window.addEventListener('mouseup', dragEnd);
        } else if(e.type === 'touchstart') {
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
          window.addEventListener('touchmove', dragging, {passive:false});
          window.addEventListener('touchend', dragEnd);
        }
        
        lastX = startX;
        lastY = startY;
        velocityX = 0;
        velocityY = 0;

        if(animationFrame) {
          cancelAnimationFrame(animationFrame);
        }
      }

      function dragging(e) {
        if (!isDragging) return;
        e.preventDefault();

        let clientX, clientY;
        if(e.type === 'mousemove') {
          clientX = e.clientX;
          clientY = e.clientY;
        } else if(e.type === 'touchmove') {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        }

        const dx = clientX - startX;
        const dy = clientY - startY;

        const newLeft = origX + dx;
        const newTop = origY + dy;

        circle.style.left = newLeft + 'px';
        circle.style.top = newTop + 'px';

        velocityX = clientX - lastX;
        velocityY = clientY - lastY;
        lastX = clientX;
        lastY = clientY;
      }

      function dragEnd(e) {
        if (!isDragging) return;
        isDragging = false;
        circle.classList.remove('active');

        window.removeEventListener('mousemove', dragging);
        window.removeEventListener('mouseup', dragEnd);
        window.removeEventListener('touchmove', dragging);
        window.removeEventListener('touchend', dragEnd);

        bounce(velocityX, velocityY);
      }

      function bounce(vx, vy) {
        let posX = parseFloat(circle.style.left);
        let posY = parseFloat(circle.style.top);

        let amplitudeX = vx * 5;
        let amplitudeY = vy * 5;

        let time = 0;
        const damping = 0.9;
        const orbitRadius = 15;

        function animate() {
          const decay = Math.pow(damping, time);

          const deltaX = amplitudeX * Math.cos(time * 0.3) * decay;
          const deltaY = amplitudeY * Math.cos(time * 0.3) * decay;

          const orbitAngle = time * 0.05;
          const orbitOffsetX = orbitRadius * Math.cos(orbitAngle);
          const orbitOffsetY = orbitRadius * Math.sin(orbitAngle);

          circle.style.left = (posX + deltaX + orbitOffsetX) + 'px';
          circle.style.top = (posY + deltaY + orbitOffsetY) + 'px';

          time++;
          animationFrame = requestAnimationFrame(animate);
        }

        animate();
      }

      // different starting points for orbiting
      (function startOrbit() {
        let time = 0;
        const orbitRadius = 15;
        const phaseOffset = (Math.PI / 2) * index;
        animationFrame = requestAnimationFrame(function orbitAnim() {
          if (isDragging) {
            animationFrame = requestAnimationFrame(orbitAnim);
            return;
          }
          const orbitAngle = time * 0.05 + phaseOffset;
          const orbitOffsetX = orbitRadius * Math.cos(orbitAngle);
          const orbitOffsetY = orbitRadius * Math.sin(orbitAngle);
          circle.style.left = (basePos.x + orbitOffsetX) + 'px';
          circle.style.top = (basePos.y + orbitOffsetY) + 'px';
          time++;
          animationFrame = requestAnimationFrame(orbitAnim);
        });
      })();

    });
  </script>
</body