<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Triangle Splitter — Fixed</title>
  <style>
    :root {
      --bg: #111;
      --board: #1b1b1b;
      --fg: #eaeaea;
      --accent: #18e66f;
      --danger: #ff4d4d;
      --square: #4da3ff;
      --muted: #999;
    }
    html, body {
      margin: 0; padding: 0; height: 100%; overflow: hidden;
      background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    #hud {
      position: fixed; inset: 0 auto auto 0; padding: 10px 12px; z-index: 10; font-weight: 600; background: transparent;
      text-shadow: 0 1px 0 rgba(0,0,0,.45);
    }
    #hud small { display:block; font-weight: 500; color: var(--muted); }
    #upgradeMsg {
      position: fixed; left: 50%; top: 10%; transform: translateX(-50%);
      font-size: 20px; padding: 10px 14px; border-radius: 10px; background: rgba(0,0,0,.35);
      backdrop-filter: blur(2px); pointer-events: none; opacity: 0; transition: opacity .25s ease;
    }
    #upgradeMsg.show { opacity: 1; }
    canvas { display:block; background: var(--board); width: 100vw; height: 100vh; }
    #overlay {
      position: fixed; inset: 0; display: grid; place-items: center; background: rgba(0,0,0,.5);
      color: white; z-index: 20; visibility: hidden; opacity: 0; transition: opacity .25s ease, visibility 0s linear .25s;
    }
    #overlay.show { visibility: visible; opacity: 1; transition: opacity .25s ease; }
    .panel {
      background: #161616; border: 1px solid #222; box-shadow: 0 15px 40px rgba(0,0,0,.5); border-radius: 14px; padding: 18px 20px; max-width: 640px;
    }
    .panel h1 { margin: 0 0 8px; font-size: 22px; }
    .panel p { margin: 6px 0; line-height: 1.4; color: #ddd; }
    .kbd { display:inline-block; border: 1px solid #333; padding: 2px 6px; border-radius: 6px; background: #0e0e0e; font-weight: 700; }
  </style>
</head>
<body>
  <div id="hud">
    <div>Score: <span id="score">0</span></div>
    <small>Move: <span class="kbd">W</span>/<span class="kbd">A</span>/<span class="kbd">S</span>/<span class="kbd">F</span> — Auto‑fire 3/s — Touch wall or enemy = lose</small>
  </div>
  <div id="upgradeMsg"></div>
  <div id="overlay">
    <div class="panel">
      <h1 id="overlayTitle">Triangle Splitter</h1>
      <p id="overlayBody"></p>
      <p><strong>Click</strong> to start / restart.</p>
      <p><small>Every 1000 pts: random upgrade (\n+1 shots/s | +25% bullet speed | +1 penetration | ±45/90/135° side shots).<br>
      Every 2000 pts: a Square boss spawns. Defeat it to freeze, clear, +1000 pts, and ramp difficulty.</small></p>
    </div>
  </div>

  <canvas id="game"></canvas>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const overlay = document.getElementById('overlay');
  const overlayTitle = document.getElementById('overlayTitle');
  const overlayBody = document.getElementById('overlayBody');
  const upgradeMsg = document.getElementById('upgradeMsg');

  function resize() { canvas.width = innerWidth; canvas.height = innerHeight; }
  addEventListener('resize', resize, { passive: true });
  resize();

  const keys = new Set();
  addEventListener('keydown', e => { keys.add(e.key.toLowerCase()); });
  addEventListener('keyup', e => { keys.delete(e.key.toLowerCase()); });

  const rand = (min, max) => Math.random() * (max - min) + min;
  const randInt = (min, max) => (Math.random() * (max - min + 1) + min) | 0; // inclusive
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  let running = false;
  let gameOver = false;
  let score = 0;
  let nextUpgradeAt = 1000;
  let nextSquareAt = 2000; // 2000, 4000, 6000, ...
  let lastFrameTime = performance.now();
  let fireTimer = 0; // seconds accumulator for auto-fire

  // Player
  const player = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    r: 18,
    speed: 240, // px/s
    dirX: 0, // last movement dir; bullets fire along this. default up.
    dirY: -1,
    update(dt) {
      let dx = 0, dy = 0;
      if (keys.has('w')) dy -= 1;
      if (keys.has('s')) dy += 1;
      if (keys.has('a')) dx -= 1;
      if (keys.has('d')) dx += 1; 
      if (dx || dy) {
        const len = Math.hypot(dx, dy);
        dx /= len; dy /= len;
        this.dirX = dx; this.dirY = dy;
        this.x += dx * this.speed * dt;
        this.y += dy * this.speed * dt;
      }
      // Border = lose
      if (this.x - this.r < 0 || this.x + this.r > canvas.width || this.y - this.r < 0 || this.y + this.r > canvas.height) lose();
      this.x = clamp(this.x, this.r, canvas.width - this.r);
      this.y = clamp(this.y, this.r, canvas.height - this.r);
    },
    draw() {
      ctx.fillStyle = '#0f0';
      ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
    }
  };

  // Upgrades
  const upgrades = {
    fireRate: 3,          
    bulletSpeed: 540,     
    penetration: 2,       
    sideLevels: 0         // 0: none, 1: ±45°, 2: ±45/90°, 3: ±45/90/135°
  };

  function awardRandomUpgrade() {
    const roll = Math.random();
    if (roll < 0.25) {
      upgrades.fireRate += 1; toast(`Upgrade: +1 shot/sec → ${upgrades.fireRate}/s`);
    } else if (roll < 0.50) {
      upgrades.bulletSpeed *= 1.25; toast(`Upgrade: +25% bullet speed`);
    } else if (roll < 0.75) {
      upgrades.penetration += 1; toast(`Upgrade: +1 penetration → ${upgrades.penetration}`);
    } else {
      upgrades.sideLevels += 1; toast(`Upgrade: Side shots +${upgrades.sideLevels} (±${45*upgrades.sideLevels}° max)`);
    }
  }

  const bullets = [];
  function spawnBullet(angle) {
    const speed = upgrades.bulletSpeed;
    bullets.push({
      x: player.x, y: player.y, r: 4,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      left: upgrades.penetration
    });
  }

  function fireBurst() {
    // Base angle from last movement; if no movement yet, default up (-90deg)
    let ax = player.dirX, ay = player.dirY;
    if (ax === 0 && ay === 0) { ax = 0; ay = -1; }
    const base = Math.atan2(ay, ax);

    spawnBullet(base);
    // Sideways mirrors at ±45, ±90, ±135 based on sideLevels
    const angles = [Math.PI/4, Math.PI/2, 3*Math.PI/4];
    for (let i = 0; i < upgrades.sideLevels && i < angles.length; i++) {
      const d = angles[i];
      spawnBullet(base + d);
      spawnBullet(base - d);
    }
  }

  // Enemies
  const triangles = [];
  const squares = []; 

  function spawnTriangle(x = rand(40, canvas.width-40), y = rand(40, canvas.height-40), size = rand(24, 36), speed = rand(60, 120)) {
    const angle = rand(0, Math.PI*2);
    triangles.push({
      x, y, size, rot: 0, rotSpeed: rand(-2, 2),
      vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
      frozen: false, freezeT: 0
    });
  }

  function spawnStartTriangles() {
    const n = randInt(3, 5);
    for (let i=0;i<n;i++) spawnTriangle();
  }

  function spawnSquare(pointsAtSpawn) {
    const hitsNeeded = 2 * (pointsAtSpawn/1000);
    const speed = 160 + 10 * (pointsAtSpawn/1000);
    squares.length = 0; // only one
    squares.push({ x: rand(80, canvas.width-80), y: rand(80, canvas.height-80), size: 86, rot: 0, rotSpeed: 3,
                   vx: Math.cos(rand(0, Math.PI*2))*speed, vy: Math.sin(rand(0, Math.PI*2))*speed,
                   hits: hitsNeeded, spawnPts: pointsAtSpawn });
  }

  // Freeze/clear phase after square defeat
  let freezePhase = 0; // 0 none, >0 countdown seconds
  let pendingSquareRemoval = false;

  function lose() {
    if (gameOver) return;
    gameOver = true; running = false;
    overlayTitle.textContent = 'You lost!';
    overlayBody.textContent = 'Click to restart. Upgrades and score reset to 0.';
    overlay.classList.add('show');
  }

  function resetGame() {
    running = true; gameOver = false; score = 0;
    nextUpgradeAt = 1000; nextSquareAt = 2000;
    triangles.length = 0; bullets.length = 0; squares.length = 0;
    freezePhase = 0; pendingSquareRemoval = false;
    player.x = canvas.width/2; player.y = canvas.height/2; player.dirX = 0; player.dirY = -1;
    upgrades.fireRate = 3; upgrades.bulletSpeed = 540; upgrades.penetration = 2; upgrades.sideLevels = 0;
    spawnStartTriangles();
    overlay.classList.remove('show');
  }

  overlay.classList.add('show');
  overlayTitle.textContent = 'Triangle Splitter';
  overlayBody.textContent = 'Stay inside. Avoid triangles and walls. Auto‑fire 3 shots/sec. Score +100 per defeated triangle. Squares spawn every 2000 pts.';

  addEventListener('click', () => {
    if (!running) resetGame();
  });

  function toast(text, ms = 1500) {
    upgradeMsg.textContent = text;
    upgradeMsg.classList.add('show');
    clearTimeout(toast._t);
    toast._t = setTimeout(() => upgradeMsg.classList.remove('show'), ms);
  }

  function update(dt) {
    if (!running) return;

    // Freeze phase logic
    if (freezePhase > 0) {
      freezePhase -= dt;
      // draw flashing overlay tint in render
      if (freezePhase <= 1 && pendingSquareRemoval) {
        // Remove square after 1s delay, award points
        squares.length = 0;
        pendingSquareRemoval = false;
        score += 1000; // award square bonus
        // Respawn wave 5–10 triangles, schedule next square 2000 pts later
        for (let i = 0; i < randInt(5,10); i++) spawnTriangle();
        nextSquareAt += 2000;
      }
      return; 
    }

    player.update(dt);

    fireTimer += dt;
    const interval = 1 / upgrades.fireRate;
    while (fireTimer >= interval) { fireTimer -= interval; fireBurst(); }

    for (let b of bullets) {
      b.x += b.vx * dt; b.y += b.vy * dt;
    }

    for (let i = bullets.length-1; i >= 0; i--) {
      const b = bullets[i];
      if (b.x < -10 || b.y < -10 || b.x > canvas.width+10 || b.y > canvas.height+10 || b.left <= 0) bullets.splice(i,1);
    }

    // Triangles
    for (let t of triangles) {
      if (t.frozen) {
        t.freezeT -= dt;
        if (t.freezeT <= 0) {
          // Split or die depending on size
          const childSize = t.size * 0.72;
          const MIN_SIZE = 12;
          if (childSize >= MIN_SIZE) {
            // spawn 2
            const jitter = 18;
            spawnTriangle(t.x + rand(-jitter,jitter), t.y + rand(-jitter,jitter), childSize, rand(80, 140));
            spawnTriangle(t.x + rand(-jitter,jitter), t.y + rand(-jitter,jitter), childSize, rand(80, 140));
          } else {
            // defeated triangle → +100
            score += 100;
          }
          // remove original
          t.remove = true;
        }
      } else {
        t.x += t.vx * dt; t.y += t.vy * dt; t.rot += t.rotSpeed * dt;
        // bounce
        if (t.x - t.size/2 < 0 && t.vx < 0) t.vx *= -1;
        if (t.x + t.size/2 > canvas.width && t.vx > 0) t.vx *= -1;
        if (t.y - t.size/2 < 0 && t.vy < 0) t.vy *= -1;
        if (t.y + t.size/2 > canvas.height && t.vy > 0) t.vy *= -1;
        // collide with player
        const dx = t.x - player.x, dy = t.y - player.y;
        if (Math.hypot(dx, dy) < player.r + t.size*0.6) lose();
      }
    }

    // Squares
    for (let s of squares) {
      s.x += s.vx * dt; s.y += s.vy * dt; s.rot += s.rotSpeed * dt;
      const half = s.size/2;
      if (s.x - half < 0 && s.vx < 0) s.vx *= -1;
      if (s.x + half > canvas.width && s.vx > 0) s.vx *= -1;
      if (s.y - half < 0 && s.vy < 0) s.vy *= -1;
      if (s.y + half > canvas.height && s.vy > 0) s.vy *= -1;
      // collide with player
      const dx = Math.max(Math.abs(player.x - s.x) - half, 0);
      const dy = Math.max(Math.abs(player.y - s.y) - half, 0);
      if (Math.hypot(dx, dy) < player.r) lose();
    }

    // Bullet collisions (triangles)
    for (let b of bullets) {
      for (let t of triangles) {
        if (t.remove || t.frozen) continue;
        const dx = t.x - b.x, dy = t.y - b.y;
        if (Math.hypot(dx, dy) <= b.r + t.size*0.6) {
          t.frozen = true; t.freezeT = 0.4; // seconds
          b.left -= 1; if (b.left <= 0) { b.left = 0; break; }
        }
      }
    }

    // Bullet collisions (squares)
    for (let b of bullets) {
      for (let s of squares) {
        const half = s.size/2;
        if (b.x > s.x-half && b.x < s.x+half && b.y > s.y-half && b.y < s.y+half) {
          if (s.hits > 0) { s.hits -= 1; b.left -= 1; }
          if (b.left <= 0) { b.left = 0; }
          if (s.hits <= 0) {
            // Square defeated: freeze everything 2s; after 1s remove square +1000
            freezePhase = 2.0;
            pendingSquareRemoval = true; // square removed at t<=1s
            // freeze all triangles and squares visually
          }
        }
      }
    }

    // Remove flagged triangles
    for (let i = triangles.length-1; i >= 0; i--) if (triangles[i].remove) triangles.splice(i,1);

    // During freezePhase completion (handled in update above),
    if (freezePhase > 0) {
      // Immediately freeze: clear all triangles (no points)
      triangles.length = 0;
    }

    // Handle milestones
    if (score >= nextUpgradeAt) {
      awardRandomUpgrade();
      nextUpgradeAt += 1000;
    }
    if (score >= nextSquareAt && squares.length === 0 && freezePhase <= 0) {
      spawnSquare(nextSquareAt); 
    }

    // HUD
    scoreEl.textContent = score.toString();
  }

  function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = '#fff';
    for (let b of bullets) { ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill(); }

    for (let t of triangles) {
      ctx.save(); ctx.translate(t.x, t.y); ctx.rotate(t.rot);
      ctx.beginPath();
      ctx.moveTo(0, -t.size*0.6);
      ctx.lineTo(t.size*0.6, t.size*0.6);
      ctx.lineTo(-t.size*0.6, t.size*0.6);
      ctx.closePath();
      ctx.fillStyle = t.frozen ? '#8a8a8a' : '#ff5252';
      ctx.fill(); ctx.restore();
    }

    for (let s of squares) {
      ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(s.rot);
      ctx.fillStyle = 'rgba(77,163,255,1)';
      ctx.fillRect(-s.size/2, -s.size/2, s.size, s.size);
      ctx.restore();
      // hits text
      ctx.fillStyle = '#cce3ff'; ctx.font = '12px system-ui'; ctx.textAlign = 'center';
      ctx.fillText(`Hits: ${s.hits}`, s.x, s.y - s.size*0.65);
    }

    player.draw();

    if (freezePhase > 0) {
      const alpha = 0.25 + 0.15*Math.sin(performance.now()/120);
      ctx.fillStyle = `rgba(100,150,255,${alpha})`;
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }
  }

  function loop(now) {
    const dt = Math.min((now - lastFrameTime)/1000, 1/30); 
    lastFrameTime = now;
    update(dt); draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>






i wrote a game in html, css and javascript. i will send you my current version and ask you to fix it so that it works correctly. here is what I want. the game starts with 3-5 triangles and a circle. the circle is a player object. the player can move it by pressing w=up, a=left, s=down or f=right, with diagonal inputs being possible (example: as for down-left). the circle shoots periodically with a shot ratio of 3 shots per second. these shots can hit up to 2 triangles until they are gone. the triangles are enemy objects. they spin around themselves and move within the screen space. if the player touches a triangle or the screen border, he loses. if the player shot hits a triangle, the triangle will stay still for a short time. afterwards, it will split into two smaller triangles as in the code. the smaller triangles have the exact same behaviour as the original triangles. if th player loses, the screen will freeze until the player presses a mouse button. if the mouse button is pressed during the freeze/lose-screen, a new game will start. upgrades and score are reset up 0 when a new game occurs. the player starts with 0 points when the game starts and receive 100 points per triangle defeated. the player can earn upgrades in a random manner. every 1000 points, he is awarded one of 4 possible upgrades: 25% for 1 extra shot per second, 25% for a 25% speed increase in shot speed (meaning 1 upgrade is 125% speed, 2 upgrades are 150% and 10 upgrades are 350% total speed upgrade), 25% for shot penetration, resulting in the shots maximum hit until it is gone being one more (1 upgrade = 3 triangles can be hit by a single shit) and 25% for sideways shot upgrade, which makes the shot mirror in a 45 degrees angle (meaning the exact same shot as the original shot happens in 45% degree angle. if more upgrades are made, this happens for the next angle as well, so 3 upgrades mean mirrored shots in 45 degree angle, 90 degree angle and 135 degree angle from the original shot. every 2000 points, also spawn squares. squares are bigger and faster than triangles but basically work the same. they need more hits until deleted (2 hits per 1000 points from spawn time). once he hit count has been matched, freeze the triangles and squares for a 2 seconds. then remove the triangles (here without point awarding) and then remove the triangle 1 second later (+1000 points awarded). then start the game loop again with 5-10 triangles. the square will spawn 2000 points later now. repeat that process with 2000 points later. heres my current not correctly working code: