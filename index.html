<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Kreise Animation</title>
<style>
    body {
        margin: 0;
        background-color: #9a8c98;
        overflow: hidden;
        user-select: none;
        position: relative;
        height: 100vh;
    }
    .circle {
        width: 150px;
        height: 150px;
        border-radius: 50%;
        background: silver;
        position: fixed;
        cursor: grab;
        z-index: 1;
        user-select: none;
        touch-action: none;
        box-shadow: 0 0 15px rgba(52,144,220,0.3);
        transition: background-color 0.3s ease;
    }
    .circle.active {
        background-color: white;
        cursor: grabbing;
    }
</style>
</head>
<body>

<div class="circle" style="top: 50px; left: 50px;"></div>
<div class="circle" style="top: 50px; right: 50px;"></div>
<div class="circle" style="bottom: 50px; left: 50px;"></div>
<div class="circle" style="bottom: 50px; right: 50px;"></div>

<script>
const circles = document.querySelectorAll('.circle');

circles.forEach((circle, index) => {
  let isDragging = false;
  let startX, startY;
  let origX, origY;
  let lastX, lastY;
  let velocityX = 0;
  let velocityY = 0;
  let animationFrame;
  let basePos = {x: 0, y: 0};

  function getInitialPos(elem) {
    const rect = elem.getBoundingClientRect();
    return {x: rect.left, y: rect.top};
  }

  basePos = getInitialPos(circle);

  circle.style.left = basePos.x + 'px';
  circle.style.top = basePos.y + 'px';

  circle.addEventListener('mousedown', dragStart);
  circle.addEventListener('touchstart', dragStart, {passive: false});

  function dragStart(e) {
    e.preventDefault();
    isDragging = true;
    circle.classList.add('active');

    const rect = circle.getBoundingClientRect();
    origX = rect.left;
    origY = rect.top;

    if (e.type === 'mousedown') {
      startX = e.clientX;
      startY = e.clientY;
      window.addEventListener('mousemove', dragging);
      window.addEventListener('mouseup', dragEnd);
    } else if (e.type === 'touchstart') {
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
      window.addEventListener('touchmove', dragging, {passive:false});
      window.addEventListener('touchend', dragEnd);
    }

    lastX = startX;
    lastY = startY;
    velocityX = 0;
    velocityY = 0;

    if (animationFrame) {
      cancelAnimationFrame(animationFrame);
    }
  }

  function dragging(e) {
    if (!isDragging) return;
    e.preventDefault();

    let clientX, clientY;
    if (e.type === 'mousemove') {
      clientX = e.clientX;
      clientY = e.clientY;
    } else if (e.type === 'touchmove') {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    }

    const dx = clientX - startX;
    const dy = clientY - startY;

    const newLeft = origX + dx;
    const newTop = origY + dy;

    circle.style.left = newLeft + 'px';
    circle.style.top = newTop + 'px';

    velocityX = clientX - lastX;
    velocityY = clientY - lastY;
    lastX = clientX;
    lastY = clientY;
  }

  function dragEnd(e) {
    if (!isDragging) return;
    isDragging = false;
    circle.classList.remove('active');

    window.removeEventListener('mousemove', dragging);
    window.removeEventListener('mouseup', dragEnd);
    window.removeEventListener('touchmove', dragging);
    window.removeEventListener('touchend', dragEnd);

    bounce(velocityX, velocityY);
  }

  function bounce(vx, vy) {
    let posX = parseFloat(circle.style.left);
    let posY = parseFloat(circle.style.top);

    let velocityX = vx * 5;
    let velocityY = vy * 5;

    const damping = 0.9;
    const orbitRadius = 15;
    const circleDiameter = 150;

    function animate() {
      const minX = 0;
      const minY = 0;
      const maxX = window.innerWidth - circleDiameter;
      const maxY = window.innerHeight - circleDiameter;

      posX += velocityX;
      posY += velocityY;

      if (posX < minX) {
        posX = minX;
        velocityX = -velocityX * damping;
      } else if (posX > maxX) {
        posX = maxX;
        velocityX = -velocityX * damping;
      }
      if (posY < minY) {
        posY = minY;
        velocityY = -velocityY * damping;
      } else if (posY > maxY) {
        posY = maxY;
        velocityY = -velocityY * damping;
      }

      velocityX *= damping;
      velocityY *= damping;

      const orbitAngle = performance.now() * 0.005;
      const orbitOffsetX = orbitRadius * Math.cos(orbitAngle);
      const orbitOffsetY = orbitRadius * Math.sin(orbitAngle);

      circle.style.left = (posX + orbitOffsetX) + 'px';
      circle.style.top = (posY + orbitOffsetY) + 'px';

      if (Math.abs(velocityX) > 0.1 || Math.abs(velocityY) > 0.1) {
        animationFrame = requestAnimationFrame(animate);
      } else {
        basePos.x = posX;
        basePos.y = posY;
        startOrbit();
      }
    }

    animate();
  }

  function startOrbit() {
    let time = 0;
    const orbitRadius = 15;
    const phaseOffset = (Math.PI / 2) * index;

    if (animationFrame) {
      cancelAnimationFrame(animationFrame);
    }

    animationFrame = requestAnimationFrame(function orbitAnim() {
      if (isDragging) {
        animationFrame = requestAnimationFrame(orbitAnim);
        return;
      }
      const orbitAngle = time * 0.05 + phaseOffset;
      const orbitOffsetX = orbitRadius * Math.cos(orbitAngle);
      const orbitOffsetY = orbitRadius * Math.sin(orbitAngle);
      circle.style.left = (basePos.x + orbitOffsetX) + 'px';
      circle.style.top = (basePos.y + orbitOffsetY) + 'px';
      time++;
      animationFrame = requestAnimationFrame(orbitAnim);
    });
  }

  startOrbit();

});
</script>

</body>
</html>
