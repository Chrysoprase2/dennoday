<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Kreise Animation</title>
<style>
    body {
        margin: 0;
        background-color: #9a8c98;
        overflow: hidden;
        user-select: none;
        position: relative;
        height: 100vh;
    }
    .circle {
        width: 150px;
        height: 150px;
        border-radius: 50%;
        background: silver;
        position: fixed;
        cursor: grab;
        z-index: 1;
        user-select: none;
        touch-action: none;
        box-shadow: 0 0 15px rgba(52,144,220,0.3);
        transition: background-color 0.3s ease;
    }
    .circle.active {
        background-color: white;
        cursor: grabbing;
    }
</style>
</head>
<body>

<div class="circle" style="top: 50px; left: 50px;"></div>
<div class="circle" style="top: 50px; right: 50px;"></div>
<div class="circle" style="bottom: 50px; left: 50px;"></div>
<div class="circle" style="bottom: 50px; right: 50px;"></div>

<script>
const circles = Array.from(document.querySelectorAll('.circle'));
const circleDiameter = 150;

function isSpaceFree(x, y) {
  if (x < 0 || y < 0 || x > window.innerWidth - circleDiameter || y > window.innerHeight - circleDiameter) return false;
  for (let c of circleObjs) {
    const dx = x - c.posX;
    const dy = y - c.posY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < circleDiameter) return false;
  }
  return true;
}

function spawnAround(circle) {
  const centerX = circle.posX + circleDiameter / 2;
  const centerY = circle.posY + circleDiameter / 2;
  const spawnDistance = circleDiameter * 1.5;
  const angles = [0, 120, 240];
  for (let angleDeg of angles) {
    const angleRad = angleDeg * Math.PI / 180;
    const x = centerX + spawnDistance * Math.cos(angleRad) - circleDiameter / 2;
    const y = centerY + spawnDistance * Math.sin(angleRad) - circleDiameter / 2;
    if (isSpaceFree(x, y)) {
      const newElem = document.createElement('div');
      newElem.classList.add('circle');
      newElem.style.left = x + 'px';
      newElem.style.top = y + 'px';
      document.body.appendChild(newElem);
      const newCircle = new Circle(newElem, circleObjs.length);
      circleObjs.push(newCircle);
    }
  }
}

class Circle {
  constructor(elem, index) {
    this.elem = elem;
    this.index = index;
    this.isDragging = false;
    this.velocityX = 0;
    this.velocityY = 0;
    this.basePos = this.getInitialPos();
    this.posX = this.basePos.x;
    this.posY = this.basePos.y;
    this.animFrame = null;
    this.lastX = 0;
    this.lastY = 0;
    this.startX = 0;
    this.startY = 0;
    this.origX = 0;
    this.origY = 0;
    this.orbitTime = 0;
    this.hasSpawnedThisBounce = false;

    this.elem.style.left = this.posX + 'px';
    this.elem.style.top = this.posY + 'px';

    this._draggingHandler = this.dragging.bind(this);
    this._dragEndHandler = this.dragEnd.bind(this);

    this.elem.addEventListener('mousedown', this.dragStart.bind(this));
    this.elem.addEventListener('touchstart', this.dragStart.bind(this), {passive:false});

    this.startOrbit();
  }

  getInitialPos() {
    const rect = this.elem.getBoundingClientRect();
    return {x: rect.left, y: rect.top};
  }

  dragStart(e) {
    e.preventDefault();
    this.isDragging = true;
    this.elem.classList.add('active');

    if (this.animFrame) {
      cancelAnimationFrame(this.animFrame);
      this.animFrame = null;
    }

    const rect = this.elem.getBoundingClientRect();
    this.origX = rect.left;
    this.origY = rect.top;

    if (e.type === 'mousedown') {
      this.startX = e.clientX;
      this.startY = e.clientY;
      window.addEventListener('mousemove', this._draggingHandler);
      window.addEventListener('mouseup', this._dragEndHandler);
    } else if (e.type === 'touchstart') {
      this.startX = e.touches[0].clientX;
      this.startY = e.touches[0].clientY;
      window.addEventListener('touchmove', this._draggingHandler, {passive:false});
      window.addEventListener('touchend', this._dragEndHandler);
    }

    this.lastX = this.startX;
    this.lastY = this.startY;
    this.velocityX = 0;
    this.velocityY = 0;
  }

  dragging(e) {
    if (!this.isDragging) return;
    e.preventDefault();

    let clientX, clientY;
    if (e.type === 'mousemove') {
      clientX = e.clientX;
      clientY = e.clientY;
    } else if (e.type === 'touchmove') {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    }

    const dx = clientX - this.startX;
    const dy = clientY - this.startY;

    let newLeft = this.origX + dx;
    let newTop = this.origY + dy;

    newLeft = Math.min(Math.max(0, newLeft), window.innerWidth - circleDiameter);
    newTop = Math.min(Math.max(0, newTop), window.innerHeight - circleDiameter);

    this.posX = newLeft;
    this.posY = newTop;

    this.elem.style.left = newLeft + 'px';
    this.elem.style.top = newTop + 'px';

    this.velocityX = clientX - this.lastX;
    this.velocityY = clientY - this.lastY;
    this.lastX = clientX;
    this.lastY = clientY;

    this.handleCollisionWhileDragging();
  }

  handleCollisionWhileDragging() {
    for (let other of circleObjs) {
      if (other === this) continue;
      if (other.isDragging) continue;

      const dx = (this.posX + circleDiameter/2) - (other.posX + circleDiameter/2);
      const dy = (this.posY + circleDiameter/2) - (other.posY + circleDiameter/2);
      const dist = Math.sqrt(dx*dx + dy*dy);

      if (dist < circleDiameter) {
        const nx = dx / dist;
        const ny = dy / dist;

        const velAlongNormal = this.velocityX * nx + this.velocityY * ny;

        if (velAlongNormal < 0) {
          this.velocityX = this.velocityX - 2 * velAlongNormal * nx;
          this.velocityY = this.velocityY - 2 * velAlongNormal * ny;

          const overlap = circleDiameter - dist;
          this.posX += nx * overlap;
          this.posY += ny * overlap;

          this.elem.style.left = this.posX + 'px';
          this.elem.style.top = this.posY + 'px';
        }
      }
    }
  }

  dragEnd(e) {
    if (!this.isDragging) return;
    this.isDragging = false;
    this.elem.classList.remove('active');

    window.removeEventListener('mousemove', this._draggingHandler);
    window.removeEventListener('mouseup', this._dragEndHandler);
    window.removeEventListener('touchmove', this._draggingHandler);
    window.removeEventListener('touchend', this._dragEndHandler);

    this.bounce(this.velocityX * 1.5, this.velocityY * 1.5);
  }

  bounce(vx, vy) {
    if (this.animFrame) {
      cancelAnimationFrame(this.animFrame);
    }

    this.velocityX = vx;
    this.velocityY = vy;

    this.hasSpawnedThisBounce = false;

    const damping = 0.9;

    const animate = () => {
      if (this.isDragging) {
        cancelAnimationFrame(this.animFrame);
        this.animFrame = null;
        return;
      }

      this.posX += this.velocityX;
      this.posY += this.velocityY;

      if (this.posX < 0) {
        this.posX = 0;
        this.velocityX = -this.velocityX * damping;
      } else if (this.posX > window.innerWidth - circleDiameter) {
        this.posX = window.innerWidth - circleDiameter;
        this.velocityX = -this.velocityX * damping;
      }
      if (this.posY < 0) {
        this.posY = 0;
        this.velocityY = -this.velocityY * damping;
      } else if (this.posY > window.innerHeight - circleDiameter) {
        this.posY = window.innerHeight - circleDiameter;
        this.velocityY = -this.velocityY * damping;
      }

      this.handleCollisionWhileBouncing();

      this.velocityX *= damping;
      this.velocityY *= damping;

      this.elem.style.left = this.posX + 'px';
      this.elem.style.top = this.posY + 'px';

      if (Math.abs(this.velocityX) > 0.1 || Math.abs(this.velocityY) > 0.1) {
        this.animFrame = requestAnimationFrame(animate);
      } else {
        this.basePos.x = this.posX;
        this.basePos.y = this.posY;
        this.animFrame = null;
        this.startOrbit();
      }
    };

    animate();
  }

  handleCollisionWhileBouncing() {
    for (let other of circleObjs) {
      if (other === this) continue;
      if (other.isDragging) continue;

      const dx = (this.posX + circleDiameter/2) - (other.posX + circleDiameter/2);
      const dy = (this.posY + circleDiameter/2) - (other.posY + circleDiameter/2);
      const dist = Math.sqrt(dx*dx + dy*dy);

      if (dist < circleDiameter) {
        const nx = dx / dist;
        const ny = dy / dist;

        const velAlongNormal = this.velocityX * nx + this.velocityY * ny;

        if (velAlongNormal < 0) {
          this.velocityX = this.velocityX - 2 * velAlongNormal * nx;
          this.velocityY = this.velocityY - 2 * velAlongNormal * ny;

          const overlap = circleDiameter - dist;
          this.posX += nx * overlap;
          this.posY += ny * overlap;

          if (!this.hasSpawnedThisBounce) {
            this.hasSpawnedThisBounce = true;
            spawnAround(this);
          }
        }
      }
    }
  }

  startOrbit() {
    if (this.animFrame) {
      cancelAnimationFrame(this.animFrame);
      this.animFrame = null;
    }
    this.orbitTime = 0;
    const orbitRadius = 15;
    const phaseOffset = (Math.PI / 2) * this.index;

    const orbitAnim = () => {
      if (this.isDragging) {
        this.animFrame = requestAnimationFrame(orbitAnim);
        return;
      }
      const orbitAngle = this.orbitTime * 0.05 + phaseOffset;
      const orbitOffsetX = orbitRadius * Math.cos(orbitAngle);
      const orbitOffsetY = orbitRadius * Math.sin(orbitAngle);
      this.elem.style.left = (this.basePos.x + orbitOffsetX) + 'px';
      this.elem.style.top = (this.basePos.y + orbitOffsetY) + 'px';
      this.orbitTime++;
      this.animFrame = requestAnimationFrame(orbitAnim);
    };

    orbitAnim();
  }
}

const circleObjs = circles.map((elem, idx) => new Circle(elem, idx));
</script>

</body>
</html>
